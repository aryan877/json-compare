{"success":true,"data":{"title":"All Shortest Word Transformations","slug":"all-shortest-word-transformations","description":"You are given two words `beginWord` and `endWord`, and a list of allowed words `wordList`. Transform `beginWord` into `endWord` by changing exactly one character at a time. Each intermediate word must exist in `wordList`.\n\nReturn all the shortest transformation sequences from `beginWord` to `endWord`.\n\nIf no such sequence exists, return an empty list.\n\nExample 1:\n```\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation: There are two shortest sequences of length 5.\n```\n\nExample 2:\n```\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: \"cog\" is not in the word list, so no transformation is possible.\n```\n\nExample 3:\n```\nInput: beginWord = \"same\", endWord = \"cost\", wordList = [\"came\",\"case\",\"cast\",\"cost\",\"cose\",\"cist\",\"sist\",\"sane\",\"sone\"]\nOutput: [[\"same\",\"sane\",\"sone\",\"cose\",\"cost\"],[\"same\",\"sane\",\"case\",\"cast\",\"cost\"]]\nExplanation: Multiple shortest sequences exist; return all of them.\n```","difficulty":"HARD","tags":["graph","bfs","dfs","backtracking","hashmap","string"],"constraints":"- All words have the same length.\n- 1 <= wordList.length <= 5000\n- 1 <= beginWord.length <= 10\n- Each word consists of lowercase English letters.\n- `beginWord` and `endWord` are non-empty strings.\n- The answer may contain many sequences; ensure solutions are optimized to avoid exploring non-shortest paths.","askedByCompanies":["amazon","google","microsoft","facebook","uber","adobe","paypal","bloomberg","apple","twitter"],"isLocked":true,"isPublished":false,"isFeatured":false,"solutionVideoUrl":"","editorialNotes":"### Intuition\nWe want all shortest transformation sequences between two words, where each step changes only one letter and must be a valid dictionary word. This is a classic shortest paths-in-unweighted-graph problem. Think of each word as a node, and draw an edge between words that differ by exactly one character. The shortest path length is found using Breadth-First Search (BFS). Once we know the minimum distance to reach each word, we can reconstruct all shortest sequences using Depth-First Search (DFS) restricted to edges that follow distance layers.\n\n### Brute Force Approach\nA naive attempt would generate all possible paths from `beginWord` to `endWord` by recursively changing one letter at a time and checking whether the word exists in the dictionary. This explores a huge search space, revisiting many nodes and exploring paths that are longer than necessary. Time complexity becomes exponential and quickly becomes infeasible for larger dictionaries.\n\n### Optimized Approach\n1. Build a fast neighbor generator by precomputing wildcard patterns. For example, for word `hot`, generate `*ot`, `h*t`, `ho*`. Maintain a map from pattern to all words matching it. This lets us find neighbors (one-letter different words) in O(L) patterns per word (L is word length).\n2. BFS from `beginWord` to compute the shortest distance to each word and build a directed adjacency map that only points from a word to neighbors at the next level (distance + 1). Stop BFS expansion beyond the level where `endWord` is first reached to avoid exploring longer paths.\n3. If `endWord` is not reached, return an empty list.\n4. Run DFS (or backtracking) from `beginWord` to `endWord` following only edges that respect increasing distance. Accumulate sequences and record all valid paths when `endWord` is reached.\n\nThis two-phase approach ensures we enumerate only shortest paths and avoid unnecessary exploration.\n\n### Code (with explanation)\n```python\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        # Convert wordList to set for O(1) membership\n        dict_set = set(wordList)\n        if endWord not in dict_set:\n            return []\n        dict_set.add(beginWord)\n        L = len(beginWord)\n\n        # Precompute wildcard buckets: e.g., h*t -> [hot, hit]\n        buckets = defaultdict(list)\n        for w in dict_set:\n            for i in range(L):\n                buckets[w[:i] + '*' + w[i+1:]].append(w)\n\n        # BFS to compute distance and next-level adjacency constrained to shortest paths only\n        dist = {beginWord: 0}\n        nexts = defaultdict(list)\n        q = deque([beginWord])\n        found_end = False\n        while q and not found_end:\n            level_visited = {}\n            for _ in range(len(q)):\n                cur = q.popleft()\n                d = dist[cur]\n                for i in range(L):\n                    pat = cur[:i] + '*' + cur[i+1:]\n                    for nei in buckets[pat]:\n                        if nei == cur:\n                            continue\n                        # First time discovered neighbor in this BFS frontier\n                        if nei not in dist:\n                            level_visited.setdefault(nei, d + 1)\n                            nexts[cur].append(nei)\n                        # If neighbor discovered at the same next level, also link (multiple parents)\n                        elif dist[nei] == d + 1:\n                            nexts[cur].append(nei)\n                \n            # Add all nodes discovered at this level into global dist and queue\n            for node, dval in level_visited.items():\n                dist[node] = dval\n                q.append(node)\n                if node == endWord:\n                    found_end = True\n\n        if endWord not in dist:\n            return []\n\n        # DFS to generate all shortest paths using nexts and dist layering\n        res = []\n        path = [beginWord]\n\n        def dfs(word):\n            if word == endWord:\n                res.append(path.copy())\n                return\n            for nei in nexts[word]:\n                if dist.get(nei, float('inf')) == dist[word] + 1:\n                    path.append(nei)\n                    dfs(nei)\n                    path.pop()\n\n        dfs(beginWord)\n        return res\n```\nExplanation:\n- We precompute neighbor buckets using wildcard patterns for O(L) lookups per word.\n- BFS stores the minimum `dist` to each word and builds `nexts` only along shortest layers.\n- Once `endWord` is reached at a level, we don't explore deeper levels.\n- DFS enumerates all paths that strictly follow `dist` increasing by 1, ensuring all are shortest.\n\n### Time & Space Complexity\n- Let N be the number of words and L be the word length.\n- Building buckets: O(N * L)\n- BFS: Each word is processed at most once, and for each we consider L patterns and the bucket lists. Amortized O(N * L + E) where E is number of edges between words differing by one letter; typically bounded by O(N * L * alphabet) but pruned by buckets.\n- DFS: Outputs all shortest paths; complexity is proportional to the size of the output. In worst case, this can be large.\n- Space: O(N * L) for buckets, O(N) for dist and nexts.\n\n### Conclusion\nBy combining BFS (to find shortest distances and constrain the graph) with DFS (to enumerate paths), we avoid exploring unnecessary routes while correctly capturing all shortest sequences. Precomputing wildcard buckets makes neighbor discovery efficient, keeping the solution performant even for larger word lists on MasterJI.","codingProblemHints":[{"id":"15a66e49-6851-413f-abdf-fc1725287fbc","text":"Model words as graph nodes and connect words that differ by exactly one character.","order":1},{"id":"1230f37c-4a18-4122-b01a-cf72c5d39fe1","text":"Use BFS from beginWord to compute the shortest distance to each reachable word. Stop expanding when you first reach endWord.","order":2},{"id":"bfcb516f-f057-4b8a-b03d-18ad918516da","text":"Precompute wildcard patterns (like h*t) to quickly find neighbors in O(L) per word.","order":3},{"id":"53bc26de-c314-4c72-ab9a-af2b38bd70f4","text":"After BFS, backtrack with DFS only along edges that increase distance by 1 to list all shortest paths.","order":4}],"codingProblemTestCases":[{"id":"2aa216dc-1ea3-434f-b3f7-4cdd37e0e997","input":"{\"beginWord\":\"hit\",\"endWord\":\"cog\",\"wordList\":[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}","expectedOutput":"[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]","isHidden":false,"order":1},{"id":"a7a81662-11c4-45ce-bdd8-b46904958ba7","input":"{\"beginWord\":\"hit\",\"endWord\":\"cog\",\"wordList\":[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}","expectedOutput":"[]","isHidden":false,"order":2},{"id":"63543036-4351-4e28-aa68-09954081e976","input":"{\"beginWord\":\"same\",\"endWord\":\"cost\",\"wordList\":[\"came\",\"case\",\"cast\",\"cost\",\"cose\",\"cist\",\"sist\",\"sane\",\"sone\"]}","expectedOutput":"[[\"same\",\"sane\",\"sone\",\"cose\",\"cost\"],[\"same\",\"sane\",\"case\",\"cast\",\"cost\"]]","isHidden":false,"order":3},{"id":"14480437-f74b-4921-bed1-0d4a3bf73bbd","input":"{\"beginWord\":\"a\",\"endWord\":\"c\",\"wordList\":[\"a\",\"b\",\"c\"]}","expectedOutput":"[[\"a\",\"c\"]]","isHidden":false,"order":4},{"id":"28cb0ea3-a1d3-4b26-a4a7-27b9376117f0","input":"{\"beginWord\":\"talk\",\"endWord\":\"tail\",\"wordList\":[\"tall\",\"tail\",\"balk\",\"tale\",\"tulk\",\"tark\",\"tauk\",\"tark\",\"tair\",\"tawk\",\"tall\",\"tall\"]}","expectedOutput":"[[\"talk\",\"tall\",\"tail\"],[\"talk\",\"talk\",\"tall\",\"tail\"]]","isHidden":false,"order":5},{"id":"3f288c36-6c04-48a6-a2df-a62be007af67","input":"{\"beginWord\":\"aaaa\",\"endWord\":\"bbbb\",\"wordList\":[\"aaab\",\"aabb\",\"abbb\",\"bbbb\",\"baaa\",\"bbaa\",\"bbba\",\"aaaa\",\"aaac\",\"aaad\",\"abaa\",\"abba\",\"bbab\",\"babb\"]}","expectedOutput":"[[\"aaaa\",\"aaab\",\"aabb\",\"abbb\",\"bbbb\"],[\"aaaa\",\"baaa\",\"bbaa\",\"bbba\",\"bbbb\"]]","isHidden":false,"order":6},{"id":"4bb933ae-7f9b-4c7a-9777-6637c9583da2","input":"{\"beginWord\":\"lost\",\"endWord\":\"cost\",\"wordList\":[\"lost\",\"cost\",\"most\",\"host\",\"post\",\"lost\",\"last\"]}","expectedOutput":"[[\"lost\",\"cost\"]]","isHidden":false,"order":7},{"id":"5de513e8-dfe0-450b-baeb-ee0b58a95c4a","input":"{\"beginWord\":\"cold\",\"endWord\":\"warm\",\"wordList\":[\"cord\",\"card\",\"ward\",\"warm\",\"cold\",\"gold\",\"told\",\"torm\",\"worm\"]}","expectedOutput":"[[\"cold\",\"cord\",\"card\",\"ward\",\"warm\"],[\"cold\",\"cord\",\"word\",\"worm\",\"warm\"]]","isHidden":false,"order":8},{"id":"7cf9dceb-d0fe-4abb-8cec-a92dc98fcac4","input":"{\"beginWord\":\"red\",\"endWord\":\"tax\",\"wordList\":[\"ted\",\"tex\",\"red\",\"tax\",\"tad\",\"rex\"]}","expectedOutput":"[[\"red\",\"ted\",\"tad\",\"tax\"],[\"red\",\"rex\",\"tex\",\"tax\"]]","isHidden":false,"order":9},{"id":"95449860-11b9-4f12-b65b-a779da4f9be8","input":"{\"beginWord\":\"abc\",\"endWord\":\"xyz\",\"wordList\":[\"abx\",\"axb\",\"xby\",\"xbz\",\"ayz\",\"xyz\",\"abc\",\"xbc\",\"xyc\"]}","expectedOutput":"[[\"abc\",\"abx\",\"xbx\",\"xby\",\"xby\",\"xzy\",\"xyz\"]]","isHidden":false,"order":10}],"codingProblemStarterTemplates":[{"id":"358d55fe-1212-4b06-8966-a37b351e7f8a","language":"javascript","code":"class Solution {\n  // Return all shortest transformation sequences from beginWord to endWord\n  // beginWord: string, endWord: string, wordList: string[]\n  findLadders(beginWord, endWord, wordList) {\n    // TODO: Implement BFS to compute shortest distances and adjacency, then DFS to build paths\n    return [];\n  }\n}\n"},{"id":"e48130ba-8ebb-4a82-9e3e-542b04e8ce34","language":"typescript","code":"class Solution {\n  // Return all shortest transformation sequences from beginWord to endWord\n  // beginWord: string, endWord: string, wordList: string[]\n  findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {\n    // TODO: Implement BFS to compute shortest distances and adjacency, then DFS to build paths\n    return [];\n  }\n}\n"},{"id":"344e2a83-a417-431e-ac75-b9dbdc73c977","language":"python","code":"class Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        beginWord: str\n        endWord: str\n        wordList: List[str]\n        returns: List[List[str]] of all shortest transformation sequences\n        \"\"\"\n        return []\n"},{"id":"5b55d8c0-74d0-43d3-90db-69c5fe9f23d1","language":"java","code":"import java.util.*;\n\nclass Solution {\n    // Return all shortest transformation sequences from beginWord to endWord\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        // TODO: Implement BFS to compute shortest distances and adjacency, then DFS to build paths\n        return new ArrayList<>();\n    }\n}\n"},{"id":"fccf3429-0d8e-46b2-a0bf-d62ac0fb74e4","language":"cpp","code":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    // Return all shortest transformation sequences from beginWord to endWord\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        // TODO: Implement BFS to compute shortest distances and adjacency, then DFS to build paths\n        return {};\n    }\n};\n"}],"codingProblemExecutionTemplates":[{"id":"0a872c16-f66c-4cbb-a223-d8d37b684114","language":"javascript","code":"const fs = require(\"fs\");\n\n{{USER_CODE}}\n\nfunction main() {\n  try {\n    const inputStr = fs.readFileSync(0, \"utf-8\");\n    const inputData = JSON.parse(inputStr);\n    const beginWord = inputData[\"beginWord\"];\n    const endWord = inputData[\"endWord\"];\n    const wordList = inputData[\"wordList\"];\n    const sol = new Solution();\n    const result = sol.findLadders(beginWord, endWord, wordList);\n    console.log(JSON.stringify(result));\n  } catch (e) {\n    console.log(JSON.stringify([]));\n  }\n}\n\nmain();\n"},{"id":"299415d0-2933-4c45-9a42-1db1bcd5ac44","language":"typescript","code":"import * as fs from \"fs\";\n\n{{USER_CODE}}\n\nfunction main() {\n  try {\n    const inputStr = fs.readFileSync(0, \"utf-8\");\n    const inputData = JSON.parse(inputStr);\n    const beginWord: string = inputData[\"beginWord\"];\n    const endWord: string = inputData[\"endWord\"];\n    const wordList: string[] = inputData[\"wordList\"];\n    const sol = new Solution();\n    const result = sol.findLadders(beginWord, endWord, wordList);\n    console.log(JSON.stringify(result));\n  } catch (e) {\n    console.log(JSON.stringify([]));\n  }\n}\n\nmain();\n"},{"id":"bdb12924-7296-435b-a07a-8c3851b01bc3","language":"python","code":"import sys, json\n\n{{USER_CODE}}\n\ndef main():\n    try:\n        input_str = sys.stdin.read()\n        data = json.loads(input_str)\n        beginWord = data[\"beginWord\"]\n        endWord = data[\"endWord\"]\n        wordList = data[\"wordList\"]\n        sol = Solution()\n        result = sol.findLadders(beginWord, endWord, wordList)\n        print(json.dumps(result, separators=(\",\", \":\")), end=\"\")\n    except Exception:\n        print(\"[]\", end=\"\")\n\nif __name__ == \"__main__\":\n    main()\n"},{"id":"467b6c83-f20f-427b-944e-b2646655038d","language":"java","code":"import com.google.gson.*;\nimport java.util.*;\n\n{{USER_CODE}}\n\nclass InputData {\n    String beginWord;\n    String endWord;\n    List<String> wordList;\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        while (sc.hasNextLine()) sb.append(sc.nextLine());\n        try {\n            Gson gson = new Gson();\n            InputData input = gson.fromJson(sb.toString(), InputData.class);\n            Solution sol = new Solution();\n            List<List<String>> res = sol.findLadders(input.beginWord, input.endWord, input.wordList);\n            System.out.print(gson.toJson(res));\n        } catch (Exception e) {\n            System.out.print(\"[]\");\n        }\n    }\n}\n"},{"id":"b1cf372a-d1bf-421f-9c8a-bd44a0d82c64","language":"cpp","code":"#include <bits/stdc++.h>\n#include \"json.hpp\"\nusing json = nlohmann::json;\nusing namespace std;\n\n{{USER_CODE}}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string inputJson; \n    string line; \n    while (getline(cin, line)) { inputJson += line; }\n    try {\n        json input = json::parse(inputJson);\n        string beginWord = input[\"beginWord\"].get<string>();\n        string endWord = input[\"endWord\"].get<string>();\n        vector<string> wordList = input[\"wordList\"].get<vector<string>>();\n        Solution sol;\n        auto result = sol.findLadders(beginWord, endWord, wordList);\n        json output = result;\n        cout << output.dump();\n    } catch (...) {\n        cout << \"[]\";\n    }\n    return 0;\n}\n"}],"codingProblemSolutions":[{"id":"ef7e59f8-b7ad-4002-9d0e-1d19cf545cd2","language":"javascript","code":"class Solution {\n  findLadders(beginWord, endWord, wordList) {\n    const dict = new Set(wordList);\n    if (!dict.has(endWord)) return [];\n    dict.add(beginWord);\n    const L = beginWord.length;\n\n    // Build buckets\n    const buckets = new Map();\n    for (const w of dict) {\n      for (let i = 0; i < L; i++) {\n        const pat = w.slice(0, i) + '*' + w.slice(i + 1);\n        if (!buckets.has(pat)) buckets.set(pat, []);\n        buckets.get(pat).push(w);\n      }\n    }\n\n    const dist = new Map([[beginWord, 0]]);\n    const nexts = new Map();\n    const q = [beginWord];\n    let foundEnd = false;\n\n    while (q.length && !foundEnd) {\n      const size = q.length;\n      const levelVisited = new Map();\n      for (let s = 0; s < size; s++) {\n        const cur = q.shift();\n        const d = dist.get(cur);\n        for (let i = 0; i < L; i++) {\n          const pat = cur.slice(0, i) + '*' + cur.slice(i + 1);\n          const arr = buckets.get(pat) || [];\n          for (const nei of arr) {\n            if (nei === cur) continue;\n            if (!dist.has(nei)) {\n              if (!levelVisited.has(nei)) levelVisited.set(nei, d + 1);\n              if (!nexts.has(cur)) nexts.set(cur, []);\n              nexts.get(cur).push(nei);\n            } else if (dist.get(nei) === d + 1) {\n              if (!nexts.has(cur)) nexts.set(cur, []);\n              nexts.get(cur).push(nei);\n            }\n          }\n        }\n      }\n      for (const [node, dval] of levelVisited) {\n        dist.set(node, dval);\n        q.push(node);\n        if (node === endWord) foundEnd = true;\n      }\n    }\n\n    if (!dist.has(endWord)) return [];\n\n    const res = [];\n    const path = [beginWord];\n\n    const dfs = (w) => {\n      if (w === endWord) {\n        res.push([...path]);\n        return;\n      }\n      const children = nexts.get(w) || [];\n      for (const nei of children) {\n        if (dist.get(nei) === dist.get(w) + 1) {\n          path.push(nei);\n          dfs(nei);\n          path.pop();\n        }\n      }\n    };\n\n    dfs(beginWord);\n    return res;\n  }\n}\n","order":1},{"id":"18898540-49e0-4f8c-bb4f-0567a1f92905","language":"typescript","code":"class Solution {\n  findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {\n    const dict = new Set<string>(wordList);\n    if (!dict.has(endWord)) return [];\n    dict.add(beginWord);\n    const L = beginWord.length;\n\n    const buckets = new Map<string, string[]>();\n    for (const w of dict) {\n      for (let i = 0; i < L; i++) {\n        const pat = w.slice(0, i) + '*' + w.slice(i + 1);\n        if (!buckets.has(pat)) buckets.set(pat, []);\n        buckets.get(pat)!.push(w);\n      }\n    }\n\n    const dist = new Map<string, number>();\n    dist.set(beginWord, 0);\n    const nexts = new Map<string, string[]>();\n    const q: string[] = [beginWord];\n    let foundEnd = false;\n\n    while (q.length && !foundEnd) {\n      const size = q.length;\n      const levelVisited = new Map<string, number>();\n      for (let s = 0; s < size; s++) {\n        const cur = q.shift() as string;\n        const d = dist.get(cur)!;\n        for (let i = 0; i < L; i++) {\n          const pat = cur.slice(0, i) + '*' + cur.slice(i + 1);\n          const arr = buckets.get(pat) || [];\n          for (const nei of arr) {\n            if (nei === cur) continue;\n            if (!dist.has(nei)) {\n              if (!levelVisited.has(nei)) levelVisited.set(nei, d + 1);\n              if (!nexts.has(cur)) nexts.set(cur, []);\n              nexts.get(cur)!.push(nei);\n            } else if (dist.get(nei) === d + 1) {\n              if (!nexts.has(cur)) nexts.set(cur, []);\n              nexts.get(cur)!.push(nei);\n            }\n          }\n        }\n      }\n      for (const [node, dval] of levelVisited) {\n        dist.set(node, dval);\n        q.push(node);\n        if (node === endWord) foundEnd = true;\n      }\n    }\n\n    if (!dist.has(endWord)) return [];\n\n    const res: string[][] = [];\n    const path: string[] = [beginWord];\n\n    const dfs = (w: string) => {\n      if (w === endWord) {\n        res.push([...path]);\n        return;\n      }\n      const children = nexts.get(w) || [];\n      for (const nei of children) {\n        if (dist.get(nei) === (dist.get(w)! + 1)) {\n          path.push(nei);\n          dfs(nei);\n          path.pop();\n        }\n      }\n    };\n\n    dfs(beginWord);\n    return res;\n  }\n}\n","order":2},{"id":"26bee2f2-4f2f-407f-8b7c-087629c92b98","language":"python","code":"from collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        dict_set = set(wordList)\n        if endWord not in dict_set:\n            return []\n        dict_set.add(beginWord)\n        L = len(beginWord)\n\n        buckets = defaultdict(list)\n        for w in dict_set:\n            for i in range(L):\n                buckets[w[:i] + '*' + w[i+1:]].append(w)\n\n        dist = {beginWord: 0}\n        nexts = defaultdict(list)\n        q = deque([beginWord])\n        found_end = False\n\n        while q and not found_end:\n            level_visited = {}\n            for _ in range(len(q)):\n                cur = q.popleft()\n                d = dist[cur]\n                for i in range(L):\n                    pat = cur[:i] + '*' + cur[i+1:]\n                    for nei in buckets[pat]:\n                        if nei == cur:\n                            continue\n                        if nei not in dist:\n                            if nei not in level_visited:\n                                level_visited[nei] = d + 1\n                            nexts[cur].append(nei)\n                        elif dist[nei] == d + 1:\n                            nexts[cur].append(nei)\n            for node, dval in level_visited.items():\n                dist[node] = dval\n                q.append(node)\n                if node == endWord:\n                    found_end = True\n\n        if endWord not in dist:\n            return []\n\n        res = []\n        path = [beginWord]\n\n        def dfs(word):\n            if word == endWord:\n                res.append(path.copy())\n                return\n            for nei in nexts[word]:\n                if dist.get(nei, float('inf')) == dist[word] + 1:\n                    path.append(nei)\n                    dfs(nei)\n                    path.pop()\n\n        dfs(beginWord)\n        return res\n","order":3},{"id":"c537b719-a06e-42f2-8af5-ca2fb6ba7f77","language":"java","code":"import java.util.*;\n\nclass Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        Set<String> dict = new HashSet<>(wordList);\n        List<List<String>> res = new ArrayList<>();\n        if (!dict.contains(endWord)) return res;\n        dict.add(beginWord);\n        int L = beginWord.length();\n\n        Map<String, List<String>> buckets = new HashMap<>();\n        for (String w : dict) {\n            for (int i = 0; i < L; i++) {\n                String pat = w.substring(0, i) + '*' + w.substring(i + 1);\n                buckets.computeIfAbsent(pat, k -> new ArrayList<>()).add(w);\n            }\n        }\n\n        Map<String, Integer> dist = new HashMap<>();\n        dist.put(beginWord, 0);\n        Map<String, List<String>> nexts = new HashMap<>();\n        Deque<String> q = new ArrayDeque<>();\n        q.offer(beginWord);\n        boolean foundEnd = false;\n\n        while (!q.isEmpty() && !foundEnd) {\n            int size = q.size();\n            Map<String, Integer> levelVisited = new HashMap<>();\n            for (int s = 0; s < size; s++) {\n                String cur = q.poll();\n                int d = dist.get(cur);\n                for (int i = 0; i < L; i++) {\n                    String pat = cur.substring(0, i) + '*' + cur.substring(i + 1);\n                    List<String> arr = buckets.getOrDefault(pat, Collections.emptyList());\n                    for (String nei : arr) {\n                        if (nei.equals(cur)) continue;\n                        if (!dist.containsKey(nei)) {\n                            levelVisited.putIfAbsent(nei, d + 1);\n                            nexts.computeIfAbsent(cur, k -> new ArrayList<>()).add(nei);\n                        } else if (dist.get(nei) == d + 1) {\n                            nexts.computeIfAbsent(cur, k -> new ArrayList<>()).add(nei);\n                        }\n                    }\n                }\n            }\n            for (Map.Entry<String, Integer> e : levelVisited.entrySet()) {\n                dist.put(e.getKey(), e.getValue());\n                q.offer(e.getKey());\n                if (e.getKey().equals(endWord)) foundEnd = true;\n            }\n        }\n\n        if (!dist.containsKey(endWord)) return res;\n\n        List<String> path = new ArrayList<>();\n        path.add(beginWord);\n        dfs(beginWord, endWord, dist, nexts, path, res);\n        return res;\n    }\n\n    private void dfs(String word, String endWord, Map<String, Integer> dist, Map<String, List<String>> nexts, List<String> path, List<List<String>> res) {\n        if (word.equals(endWord)) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        List<String> children = nexts.getOrDefault(word, Collections.emptyList());\n        for (String nei : children) {\n            if (dist.getOrDefault(nei, Integer.MAX_VALUE) == dist.get(word) + 1) {\n                path.add(nei);\n                dfs(nei, endWord, dist, nexts, path, res);\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n}\n","order":4},{"id":"a7bc5aab-2d77-4f1e-b920-b964847cebea","language":"cpp","code":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> dict(wordList.begin(), wordList.end());\n        vector<vector<string>> res;\n        if (!dict.count(endWord)) return res;\n        dict.insert(beginWord);\n        int L = (int)beginWord.size();\n\n        unordered_map<string, vector<string>> buckets;\n        buckets.reserve(dict.size() * L * 2);\n        for (const string& w : dict) {\n            for (int i = 0; i < L; ++i) {\n                string pat = w.substr(0, i) + '*' + w.substr(i + 1);\n                buckets[pat].push_back(w);\n            }\n        }\n\n        unordered_map<string, int> dist; dist.reserve(dict.size()*2);\n        dist[beginWord] = 0;\n        unordered_map<string, vector<string>> nexts; nexts.reserve(dict.size()*2);\n        deque<string> q; q.push_back(beginWord);\n        bool foundEnd = false;\n\n        while (!q.empty() && !foundEnd) {\n            int size = (int)q.size();\n            unordered_map<string, int> levelVisited; levelVisited.reserve(1024);\n            for (int s = 0; s < size; ++s) {\n                string cur = q.front(); q.pop_front();\n                int d = dist[cur];\n                for (int i = 0; i < L; ++i) {\n                    string pat = cur.substr(0, i) + '*' + cur.substr(i + 1);\n                    auto it = buckets.find(pat);\n                    if (it == buckets.end()) continue;\n                    for (const string& nei : it->second) {\n                        if (nei == cur) continue;\n                        if (!dist.count(nei)) {\n                            if (!levelVisited.count(nei)) levelVisited[nei] = d + 1;\n                            nexts[cur].push_back(nei);\n                        } else if (dist[nei] == d + 1) {\n                            nexts[cur].push_back(nei);\n                        }\n                    }\n                }\n            }\n            for (auto &kv : levelVisited) {\n                dist[kv.first] = kv.second;\n                q.push_back(kv.first);\n                if (kv.first == endWord) foundEnd = true;\n            }\n        }\n\n        if (!dist.count(endWord)) return res;\n\n        vector<string> path; path.push_back(beginWord);\n        function<void(const string&)> dfs = [&](const string& w){\n            if (w == endWord) { res.push_back(path); return; }\n            auto it = nexts.find(w);\n            if (it == nexts.end()) return;\n            for (const string& nei : it->second) {\n                auto dit = dist.find(nei);\n                if (dit != dist.end() && dit->second == dist[w] + 1) {\n                    path.push_back(nei);\n                    dfs(nei);\n                    path.pop_back();\n                }\n            }\n        };\n        dfs(beginWord);\n        return res;\n    }\n};\n","order":5}]}}