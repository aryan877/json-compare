{"success":true,"data":{"title":"All Shortest Word Chains","slug":"all-shortest-word-chains","description":"Given two strings beginWord and endWord, and a list of strings wordList, return all shortest transformation sequences from beginWord to endWord. A transformation sequence is a list of words starting with beginWord and ending with endWord, where each adjacent pair of words differs by exactly one letter, and every intermediate word must be present in wordList.\n\n- Change exactly one letter at each step.\n- All words involved have the same length.\n- Every intermediate word after each change must be in wordList. The starting word (beginWord) may or may not be in wordList.\n- A word cannot be reused within the same sequence.\n- Return all shortest sequences (any order). If no valid sequence exists, return an empty list [].\n- If beginWord equals endWord, the shortest sequence is [beginWord].\n\nExample 1:\n```\nInput:\nbeginWord = \"cat\"\nendWord = \"dog\"\nwordList = [\"cat\",\"cot\",\"cog\",\"dot\",\"dog\",\"cut\"]\n\nOutput:\n[\n  [\"cat\",\"cot\",\"dot\",\"dog\"],\n  [\"cat\",\"cot\",\"cog\",\"dog\"]\n]\n\nExplanation:\nBoth sequences change one letter at a time and every intermediate word is in the list. No shorter valid sequences exist.\n```\n\nExample 2:\n```\nInput:\nbeginWord = \"mist\"\nendWord = \"moss\"\nwordList = [\"most\",\"must\",\"mass\",\"miss\"]\n\nOutput:\n[]\n\nExplanation:\nThere is no valid transformation because endWord is not present in wordList.\n```\n\nExample 3:\n```\nInput:\nbeginWord = \"same\"\nendWord = \"same\"\nwordList = [\"lame\",\"came\",\"sane\",\"same\"]\n\nOutput:\n[\n  [\"same\"]\n]\n\nExplanation:\nThe start and end words are identical, so the shortest sequence contains just that word.\n```","difficulty":"HARD","tags":["string","graph","graphtraversal","bfs","dfs","backtracking","hashmap","set","queue"],"constraints":"- `All words have equal length: |beginWord| = |endWord| = L`\n- `1 <= L <= 10`\n- `N = number of words in wordList`\n- `1 <= N <= 5000`\n- `All words consist of lowercase English letters ('a' to 'z')`\n- `wordList contains unique words (no duplicates)`\n- `endWord must be present in wordList to have any valid sequence`\n- `beginWord may or may not be present in wordList`\n- `A word cannot be reused within the same transformation sequence`","askedByCompanies":["amazon","apple","facebook","google","microsoft","uber","adobe","bloomberg","paypal","walmart","oracle","twitter","yahoo","cisco","ibm","intel","snapchat","zillow","zoho"],"isLocked":true,"isPublished":false,"isFeatured":false,"solutionVideoUrl":"","editorialNotes":"### Intuition\nThink of each word as a stepping stone. You’re allowed to step from one stone to another only if the words differ by exactly one letter. We want to start at beginWord, end at endWord, and collect all shortest possible stepping sequences.\n\nKey ideas:\n- Model words as nodes in an unweighted graph; edges connect words 1-letter apart.\n- Shortest paths in unweighted graphs are found by BFS (breadth-first search).\n- To return all shortest sequences, we first find the shortest distance level-by-level using BFS, then backtrack (DFS) only along edges that respect the shortest distances.\n\n### Brute Force Approach (if applicable)\nA naive idea is to try every possible sequence by recursively changing one letter at a time and stopping only when you reach endWord. You’d also ensure every intermediate word is in wordList and never reuse a word.\n\nWhy it’s bad:\n- The branching factor can be huge (up to 25 choices per letter position), so the number of sequences blows up exponentially.\n- You’ll explore many long paths even though we only care about shortest ones.\n\nAn only slightly better brute force: build the full graph by checking every pair of words if they differ by one letter (O(N^2 * L)), then run BFS to get short distances and DFS to gather all shortest paths. It works but building the graph pairwise is expensive for large N.\n\n### Optimized Approach\nWe want to avoid O(N^2) neighbor checks. The classic trick is to use wildcard patterns:\n- For each word and each index i, replace the i-th character with '*'. Example: \"cat\" → \"*at\", \"c*t\", \"ca*\".\n- All words sharing a pattern differ only at that position, hence are 1-letter neighbors.\n\nPlan:\n1. Early exits:\n   - If beginWord == endWord: the answer is [[beginWord]].\n   - If endWord is not in wordList: no path exists → return [].\n2. Build a set of words that includes beginWord (even if it wasn’t in wordList).\n3. Precompute pattern_map: pattern → list of words that match it. This takes O(N * L).\n4. BFS from beginWord to compute shortest distances (dist[word]) and build forward adjacency edges (word → neighbors) only from a level to the next:\n   - For current word, generate all L patterns, fetch all neighbors from pattern_map.\n   - If a neighbor hasn’t been seen, set dist[neighbor] = dist[current] + 1 and push it to the queue.\n   - Also record an adjacency edge current → neighbor.\n   - If neighbor is already seen with the same shortest distance (dist[neighbor] == dist[current] + 1), add the adjacency edge as well (multiple parents allowed).\n   - Stop expanding further levels once endWord is first reached; this ensures we only record edges on shortest paths.\n5. DFS/backtrack from beginWord to endWord using the adjacency (which only points forward one level). This enumerates all shortest sequences.\n   - No word reuse occurs because we always move to strictly higher levels (distance increases by 1), so cycles are impossible.\n\nWhy this works:\n- BFS ensures shortest distances in an unweighted graph.\n- Building adjacency during BFS but only to next-level nodes guarantees we only keep edges that belong to shortest paths.\n- DFS then walks exactly those shortest paths, collecting all sequences.\n\n### Code (with explanation)\nPython implementation using the pattern-index trick, BFS for shortest levels, and DFS for path construction.\n\n```python\nfrom typing import List, Dict\nfrom collections import deque, defaultdict\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        # 1) Trivial case: beginWord == endWord\n        if beginWord == endWord:\n            return [[beginWord]]\n\n        word_set = set(wordList)\n        # 2) If endWord not present, no path exists\n        if endWord not in word_set:\n            return []\n        # Include beginWord for indexing neighbors\n        word_set.add(beginWord)\n\n        L = len(beginWord)\n\n        # 3) Build pattern -> words mapping\n        # For each word, for each index i, replace char i with '*' to get a pattern.\n        # Words sharing a pattern differ by exactly one letter at that position.\n        pattern_map: Dict[str, List[str]] = defaultdict(list)\n        for w in word_set:\n            for i in range(L):\n                pattern = w[:i] + '*' + w[i+1:]\n                pattern_map[pattern].append(w)\n\n        # 4) BFS to compute shortest distances and build forward adjacency\n        adjacency: Dict[str, List[str]] = defaultdict(list)  # current -> next-level neighbors\n        dist: Dict[str, int] = {beginWord: 0}\n        q = deque([beginWord])\n        found_end = False  # to stop after the level where we first see endWord\n\n        while q and not found_end:\n            level_size = len(q)\n            for _ in range(level_size):\n                cur = q.popleft()\n                cur_dist = dist[cur]\n                # Explore neighbors via patterns\n                for i in range(L):\n                    pattern = cur[:i] + '*' + cur[i+1:]\n                    # All 1-letter neighbors of cur through this position\n                    for nxt in pattern_map.get(pattern, []):\n                        if nxt == cur:\n                            continue\n                        # If nxt is discovered the first time, set its distance and push into queue\n                        if nxt not in dist:\n                            dist[nxt] = cur_dist + 1\n                            q.append(nxt)\n                            adjacency[cur].append(nxt)  # forward edge to next level\n                            if nxt == endWord:\n                                found_end = True\n                        # If nxt is exactly one level deeper, it's also a valid shortest edge\n                        elif dist[nxt] == cur_dist + 1:\n                            adjacency[cur].append(nxt)\n\n        # If we never reached endWord, no shortest path exists\n        if endWord not in dist:\n            return []\n\n        # 5) DFS to collect all shortest sequences from beginWord to endWord\n        results: List[List[str]] = []\n        path: List[str] = [beginWord]\n\n        def dfs(word: str) -> None:\n            if word == endWord:\n                results.append(path.copy())\n                return\n            for nxt in adjacency.get(word, []):\n                path.append(nxt)\n                dfs(nxt)\n                path.pop()\n\n        dfs(beginWord)\n        return results\n```\n\nExplanation highlights:\n- pattern_map allows O(1) neighbor lookup per pattern position on average, avoiding O(N^2) pairwise checks.\n- dist stores BFS levels (shortest distance from beginWord). Adding adjacency edges only when dist[nxt] == dist[cur] + 1 guarantees we keep only shortest-path edges.\n- Once we see endWord in a level, we stop exploring deeper levels (found_end) to keep the graph minimal and focused on shortest paths.\n- DFS backtracks over adjacency to collect all shortest sequences.\n\n### Time & Space Complexity\nLet N be the number of words in wordList (plus possibly beginWord) and L be the length of each word.\n\nBrute force (enumerate sequences):\n- Time: Exponential in worst-case due to huge branching and depth.\n- Space: Up to recursion depth and path storage; can also blow up.\n\nPairwise-graph build (improved brute):\n- Building edges by checking all pairs: O(N^2 * L).\n- BFS + DFS on that graph afterward: O(N + E) time and O(N + E) space; but E can be up to O(N^2).\n\nOptimized approach (pattern indexing):\n- Pattern index build: O(N * L) patterns (each constructed in O(L) string slicing, but with Python slicing cost folded into constants for given constraints).\n- BFS: Each word is popped at most once; for each pop, we visit up to L patterns and iterate through their buckets. In aggregate, every valid one-letter edge is considered O(1) times, so roughly O(N * L + E) where E is the number of one-letter edges. In practice with fixed L ≤ 10 and limited alphabet, this is efficient for N ≤ 5000.\n- DFS: The number of returned paths can be large; time to output them is proportional to the total length of all paths produced. The DFS itself follows only shortest edges, avoiding unnecessary exploration.\n- Space: O(N * L) for pattern_map, O(N) for dist and BFS queue, O(E) for adjacency, plus output size.\n\n### Conclusion\nThe problem is best seen as shortest paths in an unweighted graph of words. The winning strategy is:\n- Build a fast neighbor index using wildcard patterns to avoid O(N^2) checks.\n- Run BFS to compute shortest distances and record only forward edges between consecutive levels.\n- Backtrack with DFS along those edges to enumerate all shortest sequences.\n\nThis BFS-then-DFS pattern is a powerful template whenever you need all shortest solutions in an unweighted setting: let BFS set the “skeleton” of shortest layers, then let DFS “trace” all valid shortest routes without wandering into longer paths.","codingProblemHints":[{"id":"2a40dba4-c217-4654-8f6f-4e3d9d7829df","text":"Model the problem as an unweighted graph where each word is a node and edges connect words that differ by one letter. What traversal guarantees shortest distances in such graphs?","order":1},{"id":"05345f05-eb15-4c84-b3d8-814b4d2fec41","text":"To avoid O(n^2) neighbor checks, precompute neighbors using wildcard patterns (e.g., c*t -> {cat, cot, cut}). Be sure to add beginWord to the set for indexing, and think about an early exit condition that makes the problem impossible.","order":2},{"id":"31eca8fe-ee51-4697-a16a-17a3a1af62f6","text":"Run a level-by-level BFS from beginWord. Record each word’s distance (level) and build only forward edges from a level to the next (or store a parent list). Use a per-level visited set so nodes can have multiple parents within the same level, and stop expanding beyond the level where endWord is first reached.","order":3},{"id":"74394de2-6b99-4c06-869d-77f889a40af0","text":"After BFS fixes the shortest distance, backtrack with DFS from beginWord to endWord, only moving to neighbors whose distance is exactly +1 (or following the recorded forward edges/parents). This enumerates all shortest sequences without revisiting words or exploring longer paths.","order":4}],"codingProblemTestCases":[{"id":"75db3657-8533-4cb6-bf9d-9e87e8d177bb","input":"{\"beginWord\":\"cat\",\"endWord\":\"dog\",\"wordList\":[\"cat\",\"cot\",\"cog\",\"dot\",\"dog\",\"cut\"]}","expectedOutput":"[[\"cat\",\"cot\",\"dot\",\"dog\"],[\"cat\",\"cot\",\"cog\",\"dog\"]]","isHidden":false,"order":1},{"id":"ca6df72d-62f0-40de-803e-6b7d1ca5c5de","input":"{\"beginWord\":\"mist\",\"endWord\":\"moss\",\"wordList\":[\"most\",\"must\",\"mass\",\"miss\"]}","expectedOutput":"[]","isHidden":false,"order":2},{"id":"28f31264-9ff7-4e7c-9e23-3f2d25bb9810","input":"{\"beginWord\":\"same\",\"endWord\":\"same\",\"wordList\":[\"lame\",\"came\",\"sane\",\"same\"]}","expectedOutput":"[[\"same\"]]","isHidden":false,"order":3},{"id":"384d9577-78ec-41c6-9ed4-da55abaa3f1a","input":"{\"beginWord\":\"hit\",\"endWord\":\"hot\",\"wordList\":[\"hot\"]}","expectedOutput":"[[\"hit\",\"hot\"]]","isHidden":false,"order":4},{"id":"af95a4e4-291a-4583-be84-ea7ca049a089","input":"{\"beginWord\":\"hit\",\"endWord\":\"cog\",\"wordList\":[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}","expectedOutput":"[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]","isHidden":false,"order":5},{"id":"c719a982-d1e4-421a-a7b3-71521d40947a","input":"{\"beginWord\":\"a\",\"endWord\":\"c\",\"wordList\":[\"b\",\"c\"]}","expectedOutput":"[[\"a\",\"c\"]]","isHidden":false,"order":6},{"id":"d756def2-47a0-4766-92fb-66d9f27e1429","input":"{\"beginWord\":\"aaa\",\"endWord\":\"bbb\",\"wordList\":[\"aaa\",\"aab\",\"aba\",\"abb\",\"baa\",\"bab\",\"bba\",\"bbb\"]}","expectedOutput":"[[\"aaa\",\"aab\",\"abb\",\"bbb\"],[\"aaa\",\"aab\",\"bab\",\"bbb\"],[\"aaa\",\"aba\",\"abb\",\"bbb\"],[\"aaa\",\"aba\",\"bba\",\"bbb\"],[\"aaa\",\"baa\",\"bab\",\"bbb\"],[\"aaa\",\"baa\",\"bba\",\"bbb\"]]","isHidden":false,"order":7},{"id":"8e70e5fb-2652-4fa6-8874-29a71d600b20","input":"{\"beginWord\":\"alone\",\"endWord\":\"alone\",\"wordList\":[\"clone\",\"stone\",\"aline\"]}","expectedOutput":"[[\"alone\"]]","isHidden":false,"order":8},{"id":"958211a9-fb28-4727-9bc3-d8afccd8c163","input":"{\"beginWord\":\"aaaaaaaaaa\",\"endWord\":\"aaaaaaaaba\",\"wordList\":[\"aaaaaaaaba\",\"baaaaaaaaa\",\"aaaabaaaaa\"]}","expectedOutput":"[[\"aaaaaaaaaa\",\"aaaaaaaaba\"]]","isHidden":false,"order":9},{"id":"14b69f0d-e203-460f-8e3a-5eb447c1e60d","input":"{\"beginWord\":\"abcd\",\"endWord\":\"abef\",\"wordList\":[\"abed\",\"abcf\",\"abce\",\"abee\",\"abff\",\"abef\"]}","expectedOutput":"[[\"abcd\",\"abcf\",\"abef\"],[\"abcd\",\"abed\",\"abef\"]]","isHidden":false,"order":10}],"codingProblemStarterTemplates":[{"id":"bd53a6ab-8579-4aa9-b166-5d9e1c5b9d6f","language":"javascript","code":"class Solution {\n  findLadders(beginWord, endWord, wordList) {\n    // beginWord: string - starting word\n    // endWord: string - target word\n    // wordList: string[] - list of allowed intermediate words (may or may not include beginWord)\n    // Goal: return all shortest transformation sequences from beginWord to endWord.\n    // Guidance: Use BFS to determine shortest distances and build adjacency, then DFS/backtracking to construct all shortest paths.\n    // Handle edge cases like: endWord not in wordList, beginWord == endWord, multiple shortest paths.\n    return [];\n  }\n}\n"},{"id":"9229eda5-0226-4e98-9963-85c351223b7f","language":"typescript","code":"class Solution {\n  findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {\n    // beginWord: string - starting word\n    // endWord: string - target word\n    // wordList: string[] - list of allowed intermediate words (may or may not include beginWord)\n    // Return all shortest transformation sequences from beginWord to endWord.\n    // Hint: BFS to get shortest levels and neighbor mapping; DFS/backtracking to build all shortest paths.\n    // Optimize by precomputing neighbors via generic patterns or on-the-fly adjacency.\n    return [];\n  }\n}\n"},{"id":"80d668d0-3d71-4137-aca7-8343ee467e4b","language":"python","code":"from typing import List\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        '''\n        beginWord: starting word\n        endWord: target word\n        wordList: list of allowed intermediate words (may or may not include beginWord)\n        Returns all shortest transformation sequences from beginWord to endWord.\n        Strategy hint: Use BFS to compute shortest distances and neighbors, then DFS to enumerate all shortest paths.\n        '''\n        return []\n"},{"id":"dae926eb-43f5-4a42-91ba-8ac2063f1368","language":"java","code":"import java.util.*;\n\nclass Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        // beginWord: starting word\n        // endWord: target word\n        // wordList: list of allowed intermediate words (may or may not include beginWord)\n        // Return all shortest transformation sequences from beginWord to endWord.\n        // Approach hint: BFS for shortest path layers and neighbor graph, then DFS/backtracking to construct all shortest sequences.\n        return new ArrayList<>();\n    }\n}\n"},{"id":"dda3f922-76b2-4f5f-88bd-8e026b106975","language":"cpp","code":"#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        // beginWord: starting word\n        // endWord: target word\n        // wordList: list of allowed intermediate words (may or may not include beginWord)\n        // Return all shortest transformation sequences from beginWord to endWord.\n        // Hint: Use BFS to determine shortest distances and neighbor adjacency, then DFS/backtracking to collect all shortest paths.\n        return {};\n    }\n};\n"}],"codingProblemExecutionTemplates":[{"id":"614ffdb5-ef36-4fee-9789-8bc8f82a18a9","language":"javascript","code":"const fs = require(\"fs\");\n\n{{USER_CODE}}\n\nfunction main() {\n  try {\n    const inputStr = fs.readFileSync(0, \"utf-8\");\n    const inputData = JSON.parse(inputStr);\n\n    const beginWord = inputData[\"beginWord\"];\n    const endWord = inputData[\"endWord\"];\n    const wordList = inputData[\"wordList\"];\n\n    const sol = new Solution();\n    const result = sol.findLadders(beginWord, endWord, wordList);\n\n    console.log(JSON.stringify(result));\n  } catch (e) {\n    try {\n      console.log(JSON.stringify([]));\n    } catch (_) {\n      process.stdout.write(\"[]\");\n    }\n  }\n}\n\nmain();\n"},{"id":"75ade33c-2e70-4d18-badf-8e103fc95f6a","language":"typescript","code":"import * as fs from \"fs\";\n\n{{USER_CODE}}\n\nfunction main() {\n  try {\n    const inputStr = fs.readFileSync(0, \"utf-8\");\n    const inputData = JSON.parse(inputStr);\n\n    const beginWord: string = inputData[\"beginWord\"];\n    const endWord: string = inputData[\"endWord\"];\n    const wordList: string[] = inputData[\"wordList\"];\n\n    const sol = new Solution();\n    const result = sol.findLadders(beginWord, endWord, wordList);\n\n    console.log(JSON.stringify(result));\n  } catch (e) {\n    try {\n      console.log(JSON.stringify([]));\n    } catch {\n      process.stdout.write(\"[]\");\n    }\n  }\n}\n\nmain();\n"},{"id":"7f0f09ce-eae3-4756-989f-ad0eaa0fbe86","language":"python","code":"import sys\nimport json\n\n{{USER_CODE}}\n\ndef main():\n    try:\n        input_str = sys.stdin.read()\n        input_data = json.loads(input_str)\n\n        beginWord = input_data[\"beginWord\"]\n        endWord = input_data[\"endWord\"]\n        wordList = input_data[\"wordList\"]\n\n        sol = Solution()\n        result = sol.findLadders(beginWord, endWord, wordList)\n        print(json.dumps(result, separators=(\",\", \":\")), end=\"\")\n    except Exception:\n        sys.stdout.write(\"[]\")\n\nif __name__ == \"__main__\":\n    main()\n"},{"id":"40d21170-ce3d-49c4-8cf6-64c1f5873f33","language":"java","code":"import com.google.gson.Gson;\nimport java.util.*;\n\n{{USER_CODE}}\n\nclass InputData {\n    String beginWord;\n    String endWord;\n    List<String> wordList;\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder inputJson = new StringBuilder();\n\n        // Read full input from stdin\n        while (sc.hasNextLine()) {\n            inputJson.append(sc.nextLine());\n        }\n\n        Gson gson = new Gson();\n        try {\n            InputData input = gson.fromJson(inputJson.toString(), InputData.class);\n\n            Solution sol = new Solution();\n            List<List<String>> result = sol.findLadders(input.beginWord, input.endWord, input.wordList);\n\n            String jsonResult = gson.toJson(result);\n            System.out.print(jsonResult);\n        } catch (Exception e) {\n            System.out.print(\"[]\");\n        }\n    }\n}\n"},{"id":"112def43-a941-4809-943e-bf8aa445107f","language":"cpp","code":"#include <iostream>\n#include <vector>\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\nusing namespace std;\n\n{{USER_CODE}}\n\nint main() {\n    // Read input from stdin\n    string inputJson;\n    getline(cin, inputJson);\n\n    try {\n        // Parse input\n        json input = json::parse(inputJson);\n        string beginWord = input[\"beginWord\"];\n        string endWord = input[\"endWord\"];\n        vector<string> wordList = input[\"wordList\"];\n\n        // Solve the problem\n        Solution sol;\n        vector<vector<string>> result = sol.findLadders(beginWord, endWord, wordList);\n\n        // Output result as JSON\n        json output = result;\n        cout << output.dump();\n    } catch (...) {\n        cout << \"[]\";\n    }\n\n    return 0;\n}\n"}],"codingProblemSolutions":[{"id":"bf6b1de2-b641-4c04-b492-23012ce3bbde","language":"javascript","code":"class Solution {\n  findLadders(beginWord, endWord, wordList) {\n    if (beginWord === endWord) return [[beginWord]];\n\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return [];\n    wordSet.add(beginWord);\n\n    const wordLen = beginWord.length;\n\n    // Precompute generic pattern -> words mapping\n    const patternMap = new Map(); // pattern: string -> string[]\n    const allWords = Array.from(wordSet);\n    for (const word of allWords) {\n      for (let i = 0; i < wordLen; i++) {\n        const pattern = word.slice(0, i) + '*' + word.slice(i + 1);\n        if (!patternMap.has(pattern)) patternMap.set(pattern, []);\n        patternMap.get(pattern).push(word);\n      }\n    }\n\n    // BFS to build adjacency respecting shortest distances\n    const adjacency = new Map(); // word -> string[] next words at next level\n    const dist = new Map();\n    const queue = [];\n\n    dist.set(beginWord, 0);\n    queue.push(beginWord);\n\n    let foundEnd = false;\n\n    while (queue.length > 0 && !foundEnd) {\n      const levelSize = queue.length;\n      for (let s = 0; s < levelSize; s++) {\n        const current = queue.shift();\n        const currentDist = dist.get(current);\n        if (!adjacency.has(current)) adjacency.set(current, []);\n\n        for (let i = 0; i < wordLen; i++) {\n          const pattern = current.slice(0, i) + '*' + current.slice(i + 1);\n          const neighbors = patternMap.get(pattern) || [];\n          for (const next of neighbors) {\n            if (next === current) continue;\n            if (!dist.has(next)) {\n              dist.set(next, currentDist + 1);\n              queue.push(next);\n              adjacency.get(current).push(next);\n              if (next === endWord) foundEnd = true;\n            } else if (dist.get(next) === currentDist + 1) {\n              adjacency.get(current).push(next);\n            }\n          }\n        }\n      }\n    }\n\n    if (!dist.has(endWord)) return [];\n\n    // DFS to build all shortest paths using adjacency\n    const results = [];\n    const path = [beginWord];\n\n    const dfs = (word) => {\n      if (word === endWord) {\n        results.push(path.slice());\n        return;\n      }\n      const nexts = adjacency.get(word) || [];\n      for (const nxt of nexts) {\n        path.push(nxt);\n        dfs(nxt);\n        path.pop();\n      }\n    };\n\n    dfs(beginWord);\n    return results;\n  }\n}\n","order":1},{"id":"12245c50-98cb-4f8c-adf9-9952a603c9c3","language":"typescript","code":"class Solution {\n  findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {\n    if (beginWord === endWord) return [[beginWord]];\n\n    const wordSet: Set<string> = new Set(wordList);\n    if (!wordSet.has(endWord)) return [];\n    wordSet.add(beginWord);\n\n    const L: number = beginWord.length;\n\n    // Precompute pattern -> words mapping\n    const patternMap: Map<string, string[]> = new Map();\n    const allWords: string[] = Array.from(wordSet);\n    for (const word of allWords) {\n      for (let i = 0; i < L; i++) {\n        const pattern = word.slice(0, i) + \"*\" + word.slice(i + 1);\n        if (!patternMap.has(pattern)) patternMap.set(pattern, []);\n        patternMap.get(pattern)!.push(word);\n      }\n    }\n\n    // BFS to construct adjacency between levels (shortest paths only)\n    const adjacency: Map<string, string[]> = new Map();\n    const dist: Map<string, number> = new Map();\n    const queue: string[] = [];\n\n    dist.set(beginWord, 0);\n    queue.push(beginWord);\n\n    let foundEnd = false;\n\n    while (queue.length > 0 && !foundEnd) {\n      const size = queue.length;\n      for (let s = 0; s < size; s++) {\n        const current = queue.shift() as string;\n        const currentDist = dist.get(current)!;\n        if (!adjacency.has(current)) adjacency.set(current, []);\n\n        for (let i = 0; i < L; i++) {\n          const pattern = current.slice(0, i) + \"*\" + current.slice(i + 1);\n          const neighbors = patternMap.get(pattern) || [];\n          for (const next of neighbors) {\n            if (next === current) continue;\n            if (!dist.has(next)) {\n              dist.set(next, currentDist + 1);\n              queue.push(next);\n              adjacency.get(current)!.push(next);\n              if (next === endWord) foundEnd = true;\n            } else if (dist.get(next) === currentDist + 1) {\n              adjacency.get(current)!.push(next);\n            }\n          }\n        }\n      }\n    }\n\n    if (!dist.has(endWord)) return [];\n\n    // DFS to collect all shortest sequences\n    const results: string[][] = [];\n    const path: string[] = [beginWord];\n\n    const dfs = (word: string): void => {\n      if (word === endWord) {\n        results.push([...path]);\n        return;\n      }\n      const nexts = adjacency.get(word) || [];\n      for (const nxt of nexts) {\n        path.push(nxt);\n        dfs(nxt);\n        path.pop();\n      }\n    };\n\n    dfs(beginWord);\n    return results;\n  }\n}\n","order":2},{"id":"cbf9389d-fdf9-4b49-be1f-d35240d4fe5f","language":"python","code":"from typing import List, Dict\nfrom collections import deque, defaultdict\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        if beginWord == endWord:\n            return [[beginWord]]\n\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n        word_set.add(beginWord)\n\n        L = len(beginWord)\n\n        # Precompute pattern -> words mapping\n        pattern_map: Dict[str, List[str]] = defaultdict(list)\n        for w in word_set:\n            for i in range(L):\n                pattern = w[:i] + '*' + w[i+1:]\n                pattern_map[pattern].append(w)\n\n        # BFS to build adjacency for shortest paths only\n        adjacency: Dict[str, List[str]] = defaultdict(list)\n        dist: Dict[str, int] = {beginWord: 0}\n        q = deque([beginWord])\n        found_end = False\n\n        while q and not found_end:\n            level_size = len(q)\n            for _ in range(level_size):\n                cur = q.popleft()\n                cur_dist = dist[cur]\n                for i in range(L):\n                    pattern = cur[:i] + '*' + cur[i+1:]\n                    for nxt in pattern_map.get(pattern, []):\n                        if nxt == cur:\n                            continue\n                        if nxt not in dist:\n                            dist[nxt] = cur_dist + 1\n                            q.append(nxt)\n                            adjacency[cur].append(nxt)\n                            if nxt == endWord:\n                                found_end = True\n                        elif dist[nxt] == cur_dist + 1:\n                            adjacency[cur].append(nxt)\n\n        if endWord not in dist:\n            return []\n\n        # DFS to collect all shortest sequences\n        results: List[List[str]] = []\n        path: List[str] = [beginWord]\n\n        def dfs(word: str) -> None:\n            if word == endWord:\n                results.append(path.copy())\n                return\n            for nxt in adjacency.get(word, []):\n                path.append(nxt)\n                dfs(nxt)\n                path.pop()\n\n        dfs(beginWord)\n        return results\n","order":3},{"id":"f17caa8e-7b31-4425-b890-eb4fb7b916a0","language":"java","code":"import java.util.*;\n\nclass Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        List<List<String>> results = new ArrayList<>();\n        if (beginWord.equals(endWord)) {\n            results.add(Collections.singletonList(beginWord));\n            return results;\n        }\n\n        Set<String> wordSet = new HashSet<>(wordList);\n        if (!wordSet.contains(endWord)) return results;\n        wordSet.add(beginWord);\n\n        int L = beginWord.length();\n\n        // Precompute pattern -> words mapping\n        Map<String, List<String>> patternMap = new HashMap<>();\n        for (String w : wordSet) {\n            for (int i = 0; i < L; i++) {\n                String pattern = w.substring(0, i) + \"*\" + w.substring(i + 1);\n                patternMap.computeIfAbsent(pattern, k -> new ArrayList<>()).add(w);\n            }\n        }\n\n        // BFS to build adjacency ensuring shortest edges only\n        Map<String, List<String>> adjacency = new HashMap<>();\n        Map<String, Integer> dist = new HashMap<>();\n        Queue<String> queue = new ArrayDeque<>();\n\n        dist.put(beginWord, 0);\n        queue.offer(beginWord);\n        boolean foundEnd = false;\n\n        while (!queue.isEmpty() && !foundEnd) {\n            int size = queue.size();\n            for (int s = 0; s < size; s++) {\n                String cur = queue.poll();\n                int curDist = dist.get(cur);\n                adjacency.computeIfAbsent(cur, k -> new ArrayList<>());\n\n                for (int i = 0; i < L; i++) {\n                    String pattern = cur.substring(0, i) + \"*\" + cur.substring(i + 1);\n                    List<String> neighbors = patternMap.getOrDefault(pattern, Collections.emptyList());\n                    for (String nxt : neighbors) {\n                        if (nxt.equals(cur)) continue;\n                        if (!dist.containsKey(nxt)) {\n                            dist.put(nxt, curDist + 1);\n                            queue.offer(nxt);\n                            adjacency.get(cur).add(nxt);\n                            if (nxt.equals(endWord)) foundEnd = true;\n                        } else if (dist.get(nxt) == curDist + 1) {\n                            adjacency.get(cur).add(nxt);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!dist.containsKey(endWord)) return results;\n\n        // DFS to collect all shortest paths\n        List<String> path = new ArrayList<>();\n        path.add(beginWord);\n\n        dfs(beginWord, endWord, adjacency, path, results);\n        return results;\n    }\n\n    private void dfs(String word, String endWord, Map<String, List<String>> adjacency,\n                     List<String> path, List<List<String>> results) {\n        if (word.equals(endWord)) {\n            results.add(new ArrayList<>(path));\n            return;\n        }\n        List<String> nexts = adjacency.getOrDefault(word, Collections.emptyList());\n        for (String nxt : nexts) {\n            path.add(nxt);\n            dfs(nxt, endWord, adjacency, path, results);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n","order":4},{"id":"09a322a5-edf7-4f8a-8554-6d2412f755eb","language":"cpp","code":"#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        vector<vector<string>> results;\n        if (beginWord == endWord) {\n            results.push_back({beginWord});\n            return results;\n        }\n\n        unordered_set<string> wordSet(wordList.begin(), wordList.end());\n        if (!wordSet.count(endWord)) return results;\n        wordSet.insert(beginWord);\n\n        int L = (int)beginWord.size();\n\n        // Precompute pattern -> words mapping\n        unordered_map<string, vector<string>> patternMap;\n        patternMap.reserve(wordSet.size() * L);\n        for (const string& w : wordSet) {\n            for (int i = 0; i < L; ++i) {\n                string pattern = w.substr(0, i) + '*' + w.substr(i + 1);\n                patternMap[pattern].push_back(w);\n            }\n        }\n\n        // BFS to build adjacency for shortest paths only\n        unordered_map<string, vector<string>> adjacency;\n        unordered_map<string, int> dist;\n        queue<string> q;\n        dist[beginWord] = 0;\n        q.push(beginWord);\n        bool foundEnd = false;\n\n        while (!q.empty() && !foundEnd) {\n            int size = (int)q.size();\n            for (int s = 0; s < size; ++s) {\n                string cur = q.front(); q.pop();\n                int curDist = dist[cur];\n                // ensure adjacency entry exists\n                if (!adjacency.count(cur)) adjacency[cur] = {};\n\n                for (int i = 0; i < L; ++i) {\n                    string pattern = cur.substr(0, i) + '*' + cur.substr(i + 1);\n                    auto it = patternMap.find(pattern);\n                    if (it == patternMap.end()) continue;\n                    const vector<string>& neighbors = it->second;\n                    for (const string& nxt : neighbors) {\n                        if (nxt == cur) continue;\n                        if (!dist.count(nxt)) {\n                            dist[nxt] = curDist + 1;\n                            q.push(nxt);\n                            adjacency[cur].push_back(nxt);\n                            if (nxt == endWord) foundEnd = true;\n                        } else if (dist[nxt] == curDist + 1) {\n                            adjacency[cur].push_back(nxt);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!dist.count(endWord)) return results;\n\n        // DFS to collect all shortest paths\n        vector<string> path;\n        path.push_back(beginWord);\n        dfs(beginWord, endWord, adjacency, path, results);\n        return results;\n    }\n\nprivate:\n    void dfs(const string& word, const string& endWord,\n             unordered_map<string, vector<string>>& adjacency,\n             vector<string>& path, vector<vector<string>>& results) {\n        if (word == endWord) {\n            results.push_back(path);\n            return;\n        }\n        auto it = adjacency.find(word);\n        if (it == adjacency.end()) return;\n        for (const string& nxt : it->second) {\n            path.push_back(nxt);\n            dfs(nxt, endWord, adjacency, path, results);\n            path.pop_back();\n        }\n    }\n};\n","order":5}]}}